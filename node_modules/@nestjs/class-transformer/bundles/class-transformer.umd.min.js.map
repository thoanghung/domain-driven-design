{"version":3,"file":"class-transformer.umd.min.js","sources":["../esm5/enums/transformation-type.enum.js","../esm5/MetadataStorage.js","../esm5/storage.js","../esm5/TransformOperationExecutor.js","../esm5/utils/is-promise.util.js","../esm5/utils/get-global.util.js","../esm5/constants/default-options.constant.js","../esm5/ClassTransformer.js","../esm5/index.js","../esm5/decorators/exclude.decorator.js","../esm5/decorators/expose.decorator.js","../esm5/decorators/transform.decorator.js","../esm5/decorators/transform-class-to-class.decorator.js","../esm5/decorators/transform-class-to-plain.decorator.js","../esm5/decorators/transform-plain-to-class.decorator.js","../esm5/decorators/type.decorator.js"],"sourcesContent":["export var TransformationType;\n(function (TransformationType) {\n    TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n    TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n    TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType || (TransformationType = {}));\n//# sourceMappingURL=transformation-type.enum.js.map","import { TransformationType } from './enums';\n/**\n * Storage all library metadata.\n */\nvar MetadataStorage = /** @class */ (function () {\n    function MetadataStorage() {\n        // -------------------------------------------------------------------------\n        // Properties\n        // -------------------------------------------------------------------------\n        this._typeMetadatas = new Map();\n        this._transformMetadatas = new Map();\n        this._exposeMetadatas = new Map();\n        this._excludeMetadatas = new Map();\n        this._ancestorsMap = new Map();\n    }\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.addTypeMetadata = function (metadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map());\n        }\n        this._typeMetadatas\n            .get(metadata.target)\n            .set(metadata.propertyName, metadata);\n    };\n    MetadataStorage.prototype.addTransformMetadata = function (metadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map());\n        }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas\n                .get(metadata.target)\n                .set(metadata.propertyName, []);\n        }\n        this._transformMetadatas\n            .get(metadata.target)\n            .get(metadata.propertyName)\n            .push(metadata);\n    };\n    MetadataStorage.prototype.addExposeMetadata = function (metadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map());\n        }\n        this._exposeMetadatas\n            .get(metadata.target)\n            .set(metadata.propertyName, metadata);\n    };\n    MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map());\n        }\n        this._excludeMetadatas\n            .get(metadata.target)\n            .set(metadata.propertyName, metadata);\n    };\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true &&\n                metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        });\n    };\n    MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\n        return this.getExposedMetadatas(target).find(function (metadata) {\n            return metadata.options && metadata.options.name === name;\n        });\n    };\n    MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.getStrategy = function (target) {\n        var excludeMap = this._excludeMetadatas.get(target);\n        var exclude = excludeMap && excludeMap.get(undefined);\n        var exposeMap = this._exposeMetadatas.get(target);\n        var expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose))\n            return 'none';\n        return exclude ? 'excludeAll' : 'exposeAll';\n    };\n    MetadataStorage.prototype.getExposedMetadatas = function (target) {\n        return this.getMetadata(this._exposeMetadatas, target);\n    };\n    MetadataStorage.prototype.getExcludedMetadatas = function (target) {\n        return this.getMetadata(this._excludeMetadatas, target);\n    };\n    MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\n        return this.getExposedMetadatas(target)\n            .filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true &&\n                metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(function (metadata) { return metadata.propertyName; });\n    };\n    MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\n        return this.getExcludedMetadatas(target)\n            .filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true &&\n                metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(function (metadata) { return metadata.propertyName; });\n    };\n    MetadataStorage.prototype.clear = function () {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    };\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.getMetadata = function (metadatas, target) {\n        var metadataFromTargetMap = metadatas.get(target);\n        var metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\n        }\n        var metadataFromAncestors = [];\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\n                metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\n            }\n        }\n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    };\n    MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\n        var metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            var metadataFromTarget = metadataFromTargetMap.get(propertyName);\n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                var ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                    return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    };\n    MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\n        var metadataFromTargetMap = metadatas.get(target);\n        var metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);\n        }\n        var metadataFromAncestorsTarget = [];\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                    metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return metadataFromAncestorsTarget\n            .slice()\n            .reverse()\n            .concat((metadataFromTarget || []).slice().reverse());\n    };\n    MetadataStorage.prototype.getAncestors = function (target) {\n        if (!target)\n            return [];\n        if (!this._ancestorsMap.has(target)) {\n            var ancestors = [];\n            for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    };\n    return MetadataStorage;\n}());\nexport { MetadataStorage };\n//# sourceMappingURL=MetadataStorage.js.map","import { MetadataStorage } from './MetadataStorage';\n/**\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\n */\nexport var defaultMetadataStorage = new MetadataStorage();\n//# sourceMappingURL=storage.js.map","import { defaultMetadataStorage } from './storage';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\nfunction instantiateArrayType(arrayType) {\n    var array = new arrayType();\n    if (!(array instanceof Set) && !('push' in array)) {\n        return [];\n    }\n    return array;\n}\nvar TransformOperationExecutor = /** @class */ (function () {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    function TransformOperationExecutor(transformationType, options) {\n        this.transformationType = transformationType;\n        this.options = options;\n        // -------------------------------------------------------------------------\n        // Private Properties\n        // -------------------------------------------------------------------------\n        this.recursionStack = new Set();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n        var _this = this;\n        if (level === void 0) { level = 0; }\n        if (Array.isArray(value) || value instanceof Set) {\n            var newValue_1 = arrayType &&\n                this.transformationType === TransformationType.PLAIN_TO_CLASS\n                ? instantiateArrayType(arrayType)\n                : [];\n            value.forEach(function (subValue, index) {\n                var subSource = source ? source[index] : undefined;\n                if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n                    var realTargetType = void 0;\n                    if (typeof targetType !== 'function' &&\n                        targetType &&\n                        targetType.options &&\n                        targetType.options.discriminator &&\n                        targetType.options.discriminator.property &&\n                        targetType.options.discriminator.subTypes) {\n                        if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                                return subType.name ===\n                                    subValue[targetType.options\n                                        .discriminator.property];\n                            });\n                            var options = {\n                                newObject: newValue_1,\n                                object: subValue,\n                                property: undefined,\n                            };\n                            var newType = targetType.typeFunction(options);\n                            realTargetType === undefined\n                                ? (realTargetType = newType)\n                                : (realTargetType = realTargetType.value);\n                            if (!targetType.options.keepDiscriminatorProperty)\n                                delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] =\n                                targetType.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\n                        }\n                    }\n                    else {\n                        realTargetType = targetType;\n                    }\n                    var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n                    if (newValue_1 instanceof Set) {\n                        newValue_1.add(value_1);\n                    }\n                    else {\n                        newValue_1.push(value_1);\n                    }\n                }\n                else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue_1 instanceof Set) {\n                        newValue_1.add(subValue);\n                    }\n                    else {\n                        newValue_1.push(subValue);\n                    }\n                }\n            });\n            return newValue_1;\n        }\n        else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n        }\n        else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n        }\n        else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n        }\n        else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n        }\n        else if (!!getGlobal().Buffer &&\n            (targetType === Buffer || value instanceof Buffer) &&\n            !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n        }\n        else if (isPromise(value) && !isMap) {\n            return new Promise(function (resolve, reject) {\n                value.then(function (data) {\n                    return resolve(_this.transform(undefined, data, targetType, undefined, undefined, level + 1));\n                }, reject);\n            });\n        }\n        else if (!isMap &&\n            value !== null &&\n            typeof value === 'object' &&\n            typeof value.then === 'function') {\n            // Note: We should not enter this, as promise has been handled above\n            // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n            return value; // skip promise transformation\n        }\n        else if (typeof value === 'object' && value !== null) {\n            // try to guess the type\n            if (!targetType &&\n                value.constructor !==\n                    Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n                targetType = value.constructor;\n            if (!targetType && source)\n                targetType = source.constructor;\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n            var keys = this.getKeys(targetType, value, isMap);\n            var newValue = source ? source : {};\n            if (!source &&\n                (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                    this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                }\n                else if (targetType) {\n                    newValue = new targetType();\n                }\n                else {\n                    newValue = {};\n                }\n            }\n            var _loop_1 = function (key) {\n                if (key === '__proto__' || key === 'constructor') {\n                    return \"continue\";\n                }\n                var valueKey = key;\n                var newValueKey = key, propertyName = key;\n                if (!this_1.options.ignoreDecorators && targetType) {\n                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n                    }\n                    else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN ||\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\n                        if (exposeMetadata &&\n                            exposeMetadata.options &&\n                            exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n                // get a subvalue\n                var subValue = undefined;\n                if (value instanceof Map) {\n                    subValue = value.get(valueKey);\n                }\n                else if (value[valueKey] instanceof Function) {\n                    subValue = value[valueKey]();\n                }\n                else {\n                    subValue = value[valueKey];\n                }\n                // determine a type\n                var type = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n                }\n                else if (targetType) {\n                    var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n                    if (metadata_1) {\n                        var options = {\n                            newObject: newValue,\n                            object: value,\n                            property: propertyName,\n                        };\n                        var newType = metadata_1.typeFunction\n                            ? metadata_1.typeFunction(options)\n                            : metadata_1.reflectedType;\n                        if (metadata_1.options &&\n                            metadata_1.options.discriminator &&\n                            metadata_1.options.discriminator.property &&\n                            metadata_1.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                                        if (subValue &&\n                                            subValue instanceof Object &&\n                                            metadata_1.options.discriminator.property in subValue) {\n                                            return (subType.name ===\n                                                subValue[metadata_1.options.discriminator.property]);\n                                        }\n                                    });\n                                    type === undefined ? (type = newType) : (type = type.value);\n                                    if (!metadata_1.options.keepDiscriminatorProperty) {\n                                        if (subValue &&\n                                            subValue instanceof Object &&\n                                            metadata_1.options.discriminator.property in subValue) {\n                                            delete subValue[metadata_1.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    subValue[metadata_1.options.discriminator.property] =\n                                        metadata_1.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\n                                }\n                            }\n                            else {\n                                type = metadata_1;\n                            }\n                        }\n                        else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n                    }\n                    else if (this_1.options.targetMaps) {\n                        // try to find a type in target maps\n                        this_1.options.targetMaps\n                            .filter(function (map) {\n                            return map.target === targetType && !!map.properties[propertyName];\n                        })\n                            .forEach(function (map) { return (type = map.properties[propertyName]); });\n                    }\n                    else if (this_1.options.enableImplicitConversion &&\n                        this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        var reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n                // if value is an array try to get its custom array type\n                var arrayType_1 = Array.isArray(value[valueKey])\n                    ? this_1.getReflectedType(targetType, propertyName)\n                    : undefined;\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                var subSource = source ? source[valueKey] : undefined;\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) &&\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\n                        ((descriptor && !descriptor.set) ||\n                            newValue[newValueKey] instanceof Function))\n                        return \"continue\";\n                }\n                if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n                    var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS\n                        ? newValueKey\n                        : key;\n                    var finalValue = void 0;\n                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue =\n                            value[transformKey] === finalValue ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n                    }\n                    else {\n                        if (subValue === undefined && this_1.options.exposeDefaultValues) {\n                            // Set default value if nothing provided\n                            finalValue = newValue[newValueKey];\n                        }\n                        else {\n                            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n                            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n                        }\n                    }\n                    if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n                else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    var finalValue = subValue;\n                    finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n                    if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n            };\n            var this_1 = this;\n            // traverse over keys\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                var key = keys_1[_i];\n                _loop_1(key);\n            }\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n            return newValue;\n        }\n        else {\n            return value;\n        }\n    };\n    TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n        var _this = this;\n        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(function (metadata) {\n                if (!metadata.options)\n                    return true;\n                return _this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(function (metadata) {\n                if (!metadata.options)\n                    return true;\n                return _this.checkGroups(metadata.options.groups);\n            });\n        }\n        else {\n            metadatas = metadatas.filter(function (metadata) {\n                return (!metadata.options ||\n                    !metadata.options.groups ||\n                    !metadata.options.groups.length);\n            });\n        }\n        metadatas.forEach(function (metadata) {\n            value = metadata.transformFn({\n                value: value,\n                key: key,\n                obj: obj,\n                type: transformationType,\n                options: _this.options,\n            });\n        });\n        return value;\n    };\n    // preventing circular references\n    TransformOperationExecutor.prototype.isCircular = function (object) {\n        return this.recursionStack.has(object);\n    };\n    TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n        if (!target)\n            return undefined;\n        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    };\n    TransformOperationExecutor.prototype.getKeys = function (target, object, isMap) {\n        var _this = this;\n        // determine exclusion strategy\n        var strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === 'none')\n            strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n        // get all keys that need to expose\n        var keys = [];\n        if (strategy === 'exposeAll' || isMap) {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            }\n            else {\n                keys = Object.keys(object);\n            }\n        }\n        if (isMap) {\n            // expose & exclude do not apply for map keys only to fields\n            return keys;\n        }\n        if (!this.options.ignoreDecorators && target) {\n            // add all exposed to list of keys\n            var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata &&\n                        exposeMetadata.options &&\n                        exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            }\n            else {\n                keys = keys.concat(exposedProperties);\n            }\n            // exclude excluded properties\n            var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties_1.length > 0) {\n                keys = keys.filter(function (key) {\n                    return !excludedProperties_1.includes(key);\n                });\n            }\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return _this.checkGroups(exposeMetadata.options.groups);\n                });\n            }\n            else {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return (!exposeMetadata ||\n                        !exposeMetadata.options ||\n                        !exposeMetadata.options.groups ||\n                        !exposeMetadata.options.groups.length);\n                });\n            }\n        }\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(function (key) {\n                return _this.options.excludePrefixes.every(function (prefix) {\n                    return key.substr(0, prefix.length) !== prefix;\n                });\n            });\n        }\n        // make sure we have unique keys\n        keys = keys.filter(function (key, index, self) {\n            return self.indexOf(key) === index;\n        });\n        return keys;\n    };\n    TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n        var decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n        return decision;\n    };\n    TransformOperationExecutor.prototype.checkGroups = function (groups) {\n        if (!groups)\n            return true;\n        return this.options.groups.some(function (optionGroup) {\n            return groups.includes(optionGroup);\n        });\n    };\n    return TransformOperationExecutor;\n}());\nexport { TransformOperationExecutor };\n//# sourceMappingURL=TransformOperationExecutor.js.map","export function isPromise(p) {\n    return p !== null && typeof p === 'object' && typeof p.then === 'function';\n}\n//# sourceMappingURL=is-promise.util.js.map","/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Cannot find name 'window'.\n        return window;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    if (typeof self !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Cannot find name 'self'.\n        return self;\n    }\n}\n//# sourceMappingURL=get-global.util.js.map","/**\n * These are the default options used by any transformation operation.\n */\nexport var defaultOptions = {\n    enableCircularCheck: false,\n    enableImplicitConversion: false,\n    excludeExtraneousValues: false,\n    excludePrefixes: undefined,\n    exposeDefaultValues: false,\n    exposeUnsetFields: true,\n    groups: undefined,\n    ignoreDecorators: false,\n    strategy: undefined,\n    targetMaps: undefined,\n    version: undefined,\n};\n//# sourceMappingURL=default-options.constant.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { TransformOperationExecutor } from './TransformOperationExecutor';\nimport { TransformationType } from './enums';\nimport { defaultOptions } from './constants/default-options.constant';\nvar ClassTransformer = /** @class */ (function () {\n    function ClassTransformer() {\n    }\n    ClassTransformer.prototype.classToPlain = function (object, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.classToPlainFromExist = function (object, plainObject, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.plainToClass = function (cls, plain, options) {\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, plain, cls, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.plainToClassFromExist = function (clsObject, plain, options) {\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.classToClass = function (object, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.classToClassFromExist = function (object, fromObject, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.serialize = function (object, options) {\n        return JSON.stringify(this.classToPlain(object, options));\n    };\n    /**\n     * Deserializes given JSON string to a object of the given class.\n     */\n    ClassTransformer.prototype.deserialize = function (cls, json, options) {\n        var jsonObject = JSON.parse(json);\n        return this.plainToClass(cls, jsonObject, options);\n    };\n    /**\n     * Deserializes given JSON string to an array of objects of the given class.\n     */\n    ClassTransformer.prototype.deserializeArray = function (cls, json, options) {\n        var jsonObject = JSON.parse(json);\n        return this.plainToClass(cls, jsonObject, options);\n    };\n    return ClassTransformer;\n}());\nexport { ClassTransformer };\n//# sourceMappingURL=ClassTransformer.js.map","import { ClassTransformer } from './ClassTransformer';\nexport { ClassTransformer } from './ClassTransformer';\nexport * from './decorators';\nexport * from './interfaces';\nexport * from './enums';\nvar classTransformer = new ClassTransformer();\nexport function classToPlain(object, options) {\n    return classTransformer.classToPlain(object, options);\n}\nexport function classToPlainFromExist(object, plainObject, options) {\n    return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\nexport function plainToClass(cls, plain, options) {\n    return classTransformer.plainToClass(cls, plain, options);\n}\nexport function plainToClassFromExist(clsObject, plain, options) {\n    return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\nexport function classToClass(object, options) {\n    return classTransformer.classToClass(object, options);\n}\nexport function classToClassFromExist(object, fromObject, options) {\n    return classTransformer.classToClassFromExist(object, fromObject, options);\n}\nexport function serialize(object, options) {\n    return classTransformer.serialize(object, options);\n}\n/**\n * Deserializes given JSON string to a object of the given class.\n */\nexport function deserialize(cls, json, options) {\n    return classTransformer.deserialize(cls, json, options);\n}\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n */\nexport function deserializeArray(cls, json, options) {\n    return classTransformer.deserializeArray(cls, json, options);\n}\n//# sourceMappingURL=index.js.map","import { defaultMetadataStorage } from '../storage';\n/**\n * Marks the given class or property as excluded. By default the property is excluded in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Exclude(options) {\n    if (options === void 0) { options = {}; }\n    /**\n     * NOTE: The `propertyName` property must be marked as optional because\n     * this decorator used both as a class and a property decorator and the\n     * Typescript compiler will freak out if we make it mandatory as a class\n     * decorator only receives one parameter.\n     */\n    return function (object, propertyName) {\n        defaultMetadataStorage.addExcludeMetadata({\n            target: object instanceof Function ? object : object.constructor,\n            propertyName: propertyName,\n            options: options,\n        });\n    };\n}\n//# sourceMappingURL=exclude.decorator.js.map","import { defaultMetadataStorage } from '../storage';\n/**\n * Marks the given class or property as included. By default the property is included in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Expose(options) {\n    if (options === void 0) { options = {}; }\n    /**\n     * NOTE: The `propertyName` property must be marked as optional because\n     * this decorator used both as a class and a property decorator and the\n     * Typescript compiler will freak out if we make it mandatory as a class\n     * decorator only receives one parameter.\n     */\n    return function (object, propertyName) {\n        defaultMetadataStorage.addExposeMetadata({\n            target: object instanceof Function ? object : object.constructor,\n            propertyName: propertyName,\n            options: options,\n        });\n    };\n}\n//# sourceMappingURL=expose.decorator.js.map","import { defaultMetadataStorage } from '../storage';\n/**\n * Defines a custom logic for value transformation.\n *\n * Can be applied to properties only.\n */\nexport function Transform(transformFn, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propertyName) {\n        defaultMetadataStorage.addTransformMetadata({\n            target: target.constructor,\n            propertyName: propertyName,\n            transformFn: transformFn,\n            options: options,\n        });\n    };\n}\n//# sourceMappingURL=transform.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformClassToClass(params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result &&\n                (typeof result === 'object' || typeof result === 'function') &&\n                typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) {\n                    return classTransformer.classToClass(data, params);\n                })\n                : classTransformer.classToClass(result, params);\n        };\n    };\n}\n//# sourceMappingURL=transform-class-to-class.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformClassToPlain(params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result &&\n                (typeof result === 'object' || typeof result === 'function') &&\n                typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) {\n                    return classTransformer.classToPlain(data, params);\n                })\n                : classTransformer.classToPlain(result, params);\n        };\n    };\n}\n//# sourceMappingURL=transform-class-to-plain.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformPlainToClass(classType, params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result &&\n                (typeof result === 'object' || typeof result === 'function') &&\n                typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) {\n                    return classTransformer.plainToClass(classType, data, params);\n                })\n                : classTransformer.plainToClass(classType, result, params);\n        };\n    };\n}\n//# sourceMappingURL=transform-plain-to-class.decorator.js.map","import { defaultMetadataStorage } from '../storage';\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n *\n * Can be applied to properties only.\n */\nexport function Type(typeFunction, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propertyName) {\n        var reflectedType = Reflect.getMetadata('design:type', target, propertyName);\n        defaultMetadataStorage.addTypeMetadata({\n            target: target.constructor,\n            propertyName: propertyName,\n            reflectedType: reflectedType,\n            typeFunction: typeFunction,\n            options: options,\n        });\n    };\n}\n//# sourceMappingURL=type.decorator.js.map"],"names":["TransformationType","defaultMetadataStorage","MetadataStorage","this","_typeMetadatas","Map","_transformMetadatas","_exposeMetadatas","_excludeMetadatas","_ancestorsMap","prototype","addTypeMetadata","metadata","has","target","set","get","propertyName","addTransformMetadata","push","addExposeMetadata","addExcludeMetadata","findTransformMetadatas","transformationType","findMetadatas","filter","options","toClassOnly","toPlainOnly","CLASS_TO_CLASS","PLAIN_TO_CLASS","CLASS_TO_PLAIN","findExcludeMetadata","findMetadata","findExposeMetadata","findExposeMetadataByCustomName","name","getExposedMetadatas","find","findTypeMetadata","getStrategy","excludeMap","exclude","undefined","exposeMap","expose","getMetadata","getExcludedMetadatas","getExposedProperties","map","getExcludedProperties","clear","metadatas","metadataFromTarget","metadataFromTargetMap","Array","from","values","meta","metadataFromAncestors","_i","_a","getAncestors","length","ancestor","ancestorMetadataMap","metadataFromAncestor","apply","concat","ancestorResult","metadataFromAncestorsTarget","slice","reverse","ancestors","baseClass","Object","getPrototypeOf","constructor","TransformOperationExecutor","recursionStack","Set","transform","source","value","targetType","arrayType","isMap","level","p","_this","isArray","newValue_1","array","instantiateArrayType","forEach","subValue","index","subSource","enableCircularCheck","isCircular","add","realTargetType","discriminator","property","subTypes","subType","newObject","object","newType","typeFunction","keepDiscriminatorProperty","value_1","String","Number","Boolean","Date","valueOf","globalThis","global","window","self","Buffer","then","keys","getKeys","newValue","_loop_1","key","valueKey","newValueKey","this_1","ignoreDecorators","exposeMetadata","Function","type","isSubValueMap","metadata_1","reflectedType","targetMaps","properties","enableImplicitConversion","Reflect","arrayType_1","getReflectedType","descriptor","getOwnPropertyDescriptor","finalValue","applyCustomTransformations","exposeUnsetFields","transformKey","exposeDefaultValues","keys_1","delete","Promise","resolve","reject","data","obj","version","checkVersion","since","until","groups","checkGroups","transformFn","strategy","exposedProperties","excludeExtraneousValues","excludedProperties_1","includes","excludePrefixes","every","prefix","substr","indexOf","decision","some","optionGroup","defaultOptions","__assign","assign","t","s","i","n","arguments","hasOwnProperty","call","ClassTransformer","classToPlain","classToPlainFromExist","plainObject","plainToClass","cls","plain","plainToClassFromExist","clsObject","classToClass","classToClassFromExist","fromObject","serialize","JSON","stringify","deserialize","json","jsonObject","parse","deserializeArray","classTransformer","params","propertyKey","originalMethod","args","result","isPromise","classType"],"mappings":"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"}